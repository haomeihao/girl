- 多线程

1.上下文切换是非常耗效率的。
``` 
通常有以下解决方案:
- 采用无锁编程，比如将数据按照 Hash(id) 进行取模分段，每个线程处理各自分段的数据，从而避免使用锁
- 采用 CAS(compare and swap) 算法，如 Atomic 包就是采用 CAS 算法(详见)
- 合理的创建线程，避免创建了一些线程但其中大部分都是出于 waiting 状态，因为每当从 waiting 状态切换到 running 状态都是一次上下文切换
```

2.死锁
``` 
死锁的场景一般是：线程 A 和线程 B 都在互相等待对方释放锁，或者是其中某个线程在释放锁的时候出现异常如死循环之类的。这时就会导致系统不可用
通常有以下解决方案:
- 尽量一个线程只获取一个锁
- 一个线程只占用一个资源
- 尝试使用定时锁，至少能保证锁最终会被释放
```

3.资源限制
``` 
当在带宽有限的情况下一个线程下载某个资源需要 1M/S,当开 10 个线程时速度并不会乘 10 倍，反而还会增加时间，毕竟上下文切换比较耗时。

如果是受限于资源的话可以采用集群来处理任务，不同的机器来处理不同的数据，就类似于开始提到的无锁编程
```

- Synchronize 关键字原理

1.实现原理
``` 
实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。
具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。

其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。
```

2.锁优化
``` 
synchronize 很多都称之为重量锁，JDK1.6 中对 synchronize 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁
```

- Java 多线程三大核心

1.原子性
```  
Java 的原子性就和数据库事物的原子性差不多，一个操作中要么全部执行成功或者失败
synchronize 或者是 lock 进行加锁处理
如果是基础类的自增操作可以使用 AtomicInteger 这样的原子类来实现(其本质是利用了 CPU 级别的 的 CAS 指令来完成的)
```

2.可见性
```  
volatile 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。

使用 volatile 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存

synchronize和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 volatile 相比开销较大
```

3. 顺序性
```
 
JVM指令重排序：重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题

Java 中可以使用 volatile 来保证顺序性，synchronize 和 lock 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。

除了通过 volatile 关键字显式的保证顺序之外， JVM 还通过 happen-before 原则来隐式的保证顺序性

1.volatile 的应用

    双重检查锁的单例模式
    
    控制停止线程的标记
    
    volatile 关键字只能保证可见性，顺序性，不能保证原子性
``` 

- 对锁的一些认知
1.同一进程
``` 
重入锁 ReentrantLock

读写锁 ReentrantReadWriteLock
  通过读写锁的分离可以很大程度的提高并发量和吞吐量
 
```

2.不同进程
``` 
分布式锁：
  1.基于数据库
  2.基于 Redis
    使用 setNX(key) setEX(timeout) 命令，只有在该 key 不存在的时候创建和这个 key，就相当于获取了锁。由于有超时时间，所以过了规定时间会自动删除，这样也可以避免死锁
    https://crossoverjie.top/2018/03/29/distributed-lock/distributed-lock-redis/
  3.基于 ZK
  
```
